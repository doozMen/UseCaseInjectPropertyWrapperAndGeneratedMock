//
//  UseCaseInjectTests-UseCaseInjectMocks.generated.swift
//  UseCaseInject
//
//  Generated by Mockingbird v0.14.1.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import UseCaseInject
import Foundation
import Resolver
import Swift

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked Bar

public final class BarMock: UseCaseInject.Bar, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.1", "module_name": "UseCaseInject"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> BarMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked foo

  override public var `foo`: UseCaseInject.Foo { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFoo() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UseCaseInject.Foo, UseCaseInject.Foo> { fatalError("See 'Thunk Stubs' in the README") }

  public func setFoo(_ newValue: @escaping @autoclosure () -> UseCaseInject.Foo) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (UseCaseInject.Foo) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked fooLazy

  override public var `fooLazy`: UseCaseInject.Foo { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFooLazy() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UseCaseInject.Foo, UseCaseInject.Foo> { fatalError("See 'Thunk Stubs' in the README") }

  public func setFooLazy(_ newValue: @escaping @autoclosure () -> UseCaseInject.Foo) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (UseCaseInject.Foo) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked fooOptional

  override public var `fooOptional`: UseCaseInject.Foo? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public func getFooOptional() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UseCaseInject.Foo?, UseCaseInject.Foo?> { fatalError("See 'Thunk Stubs' in the README") }

  public func setFooOptional(_ newValue: @escaping @autoclosure () -> UseCaseInject.Foo?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (UseCaseInject.Foo?) -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init()

  public required override init() { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(Bar.self).initialize(…)`.
public func mock(_ type: UseCaseInject.Bar.Type, file: StaticString = #file, line: UInt = #line) -> BarMock.InitializerProxy.Type {
  return BarMock.InitializerProxy.self
}

// MARK: - Mocked Foo

public final class FooMock: UseCaseInject.Foo, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.1", "module_name": "UseCaseInject"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`from` `decoder`: Decoder, __file: StaticString = #file, __line: UInt = #line) throws -> FooMock { fatalError("See 'Thunk Stubs' in the README") }

    public static func initialize(`info`: String, __file: StaticString = #file, __line: UInt = #line) -> FooMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked init(`from` `decoder`: Decoder)

  public required init(`from` `decoder`: Decoder) throws { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init(`info`: String)

  public required override init(`info`: String) { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(Foo.self).initialize(…)`.
public func mock(_ type: UseCaseInject.Foo.Type, file: StaticString = #file, line: UInt = #line) -> FooMock.InitializerProxy.Type {
  return FooMock.InitializerProxy.self
}

// MARK: - Mocked Servicable

public final class ServicableMock: UseCaseInject.Servicable, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.1", "module_name": "UseCaseInject"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      ServicableMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`()

  public func `fetch`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`() -> Void", arguments: [], returnType: Swift.ObjectIdentifier((Void).self))
    self.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `fetch`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`() -> Void", arguments: [], returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `Servicable`.
public func mock(_ type: UseCaseInject.Servicable.Protocol, file: StaticString = #file, line: UInt = #line) -> ServicableMock {
  return ServicableMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked Service

public final class ServiceMock: UseCaseInject.Service, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.14.1", "module_name": "UseCaseInject"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Stubs' in the README") } set { fatalError("See 'Thunk Stubs' in the README") } }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> ServiceMock { fatalError("See 'Thunk Stubs' in the README") }
  }

  // MARK: Mocked `fetch`()

  public override func `fetch`() -> Void { fatalError("See 'Thunk Stubs' in the README") }

  public func `fetch`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> { fatalError("See 'Thunk Stubs' in the README") }

  // MARK: Mocked init()

  public required override init() { fatalError("See 'Thunk Stubs' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(Service.self).initialize(…)`.
public func mock(_ type: UseCaseInject.Service.Type, file: StaticString = #file, line: UInt = #line) -> ServiceMock.InitializerProxy.Type {
  return ServiceMock.InitializerProxy.self
}
